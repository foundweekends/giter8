<!DOCTYPE html SYSTEM "about:legacy-compat">
<html manifest="pamflet.manifest">
      <head>
        <meta charset="utf-8"/>
        <meta content="width=device-width, initial-scale=1" name="viewport"/>
        <title>Giter8 — Combined Pages</title>
        
        <link rel="stylesheet" href="css/bootstrap.min.css" type="text/css"/>
        <link rel="stylesheet" href="css/pamflet.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/pamflet-print.css" type="text/css" media="print"/>
        <link rel="stylesheet" href="css/pamflet-grid.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <link rel="stylesheet" href="css/color_scheme-redmond.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-github.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-monokai.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/pamfletheight_2em_2em.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <script type="text/javascript" src="js/jquery-3.3.1.min.js"></script>
        <script type="text/javascript" src="js/bootstrap.bundle.min.js"></script>
        <script type="text/javascript" src="js/pamflet.js"></script>
        <script type="text/javascript">
          Pamflet.page.language = 'en';
        </script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"/><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <link rel="stylesheet" href="css/custom.css" type="text/css" media="screen, projection"/>
        
        
      </head>
      <body class="color_scheme-github">
        <div class="container-fluid contentswrapper h-100">
          <div class="row minh-100">
          <div class="col-md-4 col-xl-3 leftcolumn">&nbsp;</div><div class="col-md-8 col-xs-9">
                  <div class="rightcolmn contents">
                    <div class="tocwrapper">
        
        <div class="tocbody show" id="toc">
        <h4 class="toctitle">Contents</h4>
        <div><a href="#Giter8">Giter8</a></div><ol class="toc"> <li><div><a href="#Setup">Setup</a></div></li><li><div><a href="#Usage">Usage</a></div></li><li><div><a href="#Making+your+own+templates">Making your own templates</a></div><ol class="toc"> <li><div><a href="#Formatting+template+fields">Formatting template fields</a></div></li><li><div><a href="#Testing+templates+locally">Testing templates locally</a></div></li> </ol></li><li><div><a href="#Scaffolding+plugin">Scaffolding plugin</a></div><ol class="toc">  </ol></li><li><div><a href="#Contributing">Contributing</a></div></li> </ol></div>
      </div><h1 id="Giter8">Giter8<a href="#Giter8" class="header-link"><span class="header-link-content">&nbsp;</span></a></h1><p>Giter8 is a command line tool to generate files and directories from
templates published on GitHub or any other git repository.
It’s implemented in Scala and runs through the
<a href="https://www.scala-sbt.org/1.x/docs/Setup.html">sbt launcher</a>, but it can produce
output for any purpose.
</p><h3 id="sbt+new+integration">sbt new integration<a href="#sbt+new+integration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Starting sbt 0.13.13, Giter8 can be called from sbt’s <a href="https://www.scala-sbt.org/1.x/docs/sbt-new-and-Templates.html">&quot;new&quot; command</a> as follows:
</p><pre><code class="">$ sbt new scala/scala-seed.g8
</code></pre><h3 id="Credits">Credits<a href="#Credits" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Original implementation (C) 2010-2015 Nathan Hamblen and contributors
</li><li>Adapted and extended in 2016 by foundweekends project
</li></ul><p>Giter8 is licensed under Apache 2.0 license
</p><h2 id="Setup">Setup<a href="#Setup" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h4 id="Coursier">Coursier<a href="#Coursier" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Giter8 and other Scala command line tools can be installed using <a href="https://get-coursier.io/">Coursier</a>. 
See the coursier <a href="https://get-coursier.io/docs/cli-installation">installation instruction</a> to add it to your path.
Once <code>cs</code> is on your path, you can install giter8 with this command:
</p><pre><code>$ cs install giter8
</code></pre><p>and update it using:
</p><pre><code>$ cs update g8
</code></pre><h4 id="Manual">Manual<a href="#Manual" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>It’s possible to manually download and install giter8 directly from Maven Central:
</p><pre><code>$ curl https://repo1.maven.org/maven2/org/foundweekends/giter8/giter8-bootstrap_2.12/0.14.0/giter8-bootstrap_2.12-0.14.0.sh &gt; ~/bin/g8
$ chmod +x ~/bin/g8
</code></pre><p>Replace <code>~/bin/</code> with anything that is on your <code>PATH</code>. To make sure everything is working, try running <code>g8</code> with no
parameters, you should see
</p><pre><code>Error: Missing argument &lt;template&gt;
Try --help for more information.
</code></pre><h2 id="Usage">Usage<a href="#Usage" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Template repositories can reside on GitHub and should be named with the
suffix <code>.g8</code>. We’re keeping a <a href="https://github.com/foundweekends/giter8/wiki/giter8-templates">list of templates on the wiki</a>.
</p><p>To apply a template, for example, <a href="https://github.com/unfiltered/unfiltered.g8">unfiltered/unfiltered.g8</a>:
</p><pre><code>$ g8 unfiltered/unfiltered.g8
</code></pre><p>Giter8 resolves this to the <code>unfiltered/unfiltered.g8</code>
repository and queries GitHub for the project’s template
parameters.
Alternatively, you can also use a git repository full name
</p><pre><code>$ g8 https://gitlab.com/unfiltered/unfiltered-gitlab.g8.git
</code></pre><p>or even a local template, using the <code>file://</code> protocol:
</p><pre><code>$ g8 file://path/to/template
</code></pre><p>For remote or local repositories it’s possible to fetch a specific branch,
a specific tag or even a specific directory using command-line arguments:
</p><pre><code>-b, --branch &lt;value&gt;     Resolve a template within a given branch
-t, --tag &lt;value&gt;        Resolve a template within a given tag
-d, --directory &lt;value&gt;  Resolve a template within the given 
                         subdirectory in the repo
</code></pre><p> The default enclosing directory is <code>.</code>.
</p><p>You’ll be prompted for each parameter, with its default
value in square brackets:
</p><pre><code>name [My Web Project]: 
</code></pre><p>Enter your own value or press enter to accept the default. After all
values have been supplied, giter8 fetches the templates, applies
the parameters, and writes them to your filesystem. 
</p><p>If the template has a <code>name</code> parameter, it will be used to create base 
directory in the current directory (typical for a new project). 
Otherwise, giter8 will output its files and directories into 
the current directory, skipping over any files that already exist.
</p><p>An output directory can be specified:
</p><pre><code>-o, --out &lt;value&gt;        Output directory
</code></pre><p>this will override the generation of the directory’s name according to the value
of the <code>name</code> variable and the current directory as the enclosing one.
</p><p>To overwrite existing files in the destination folder, you can use:
</p><pre><code>-f, --force              Force overwrite of any existing files in 
                         output directory
</code></pre><p>Once you become familiar with a template’s parameters, you can enter
them on the command line and skip the interaction:
</p><pre><code>$ g8 unfiltered/unfiltered.g8 --name=my-new-website
</code></pre><p>Any unsupplied parameters are assigned their default values.
</p><h3 id="Private+Repositories">Private Repositories<a href="#Private+Repositories" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Giter8 will use your ssh key to access private repositories, just like git does.
</p><h3 id="SSH+Agent">SSH Agent<a href="#SSH+Agent" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Giter8 now support proxying to an SSH Agent which can be useful if you are using another SSH agent
such as <code>gpg-agent</code>.
</p><p>Consider the following example:
</p><p><code>~/.gitconfig</code>:
</p><pre><code>[url &quot;ssh://git@github.com&quot;]
    insteadOf = https://github.com
</code></pre><p><code>~/.profile</code>:
</p><pre><code>export SSH_AUTH_SOCK=&quot;$(gpgconf --list-dirs agent-ssh-socket)&quot;
gpgconf --launch gpg-agent 
</code></pre><p>Then this would have previously failed with:
</p><pre><code>$ g8 unfiltered/unfiltered.g8

ssh://git@github.com/unfiltered/unfiltered.g8.git: Auth fail
</code></pre><p>This now works provided that the GitHub public key is in your known hosts file.
</p><p>You can do this by running:
</p><pre><code>$ ssh -T git@github.com
</code></pre><p>Optionally the known hosts file can be overridden using:
</p><pre><code>-h, --known-hosts &lt;value&gt;  SSH known hosts file. If unset the location 
                           will be guessed.
</code></pre><h2 id="Making+your+own+templates">Making your own templates<a href="#Making+your+own+templates" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Use+CC0+1.0+for+template+licensing">Use CC0 1.0 for template licensing<a href="#Use+CC0+1.0+for+template+licensing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>We recommend licensing software templates under <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0 1.0</a>,
which waives all copyrights and related rights, similar to the “public domain.”
</p><p>If you reside in a country covered by the Berne Convention, such as the US,
copyright will arise automatically without registration.
Thus, people won’t have legal right to use your template if you do not
declare the terms of license.
The tricky thing is that even permissive licenses such as MIT License and Apache License will
require attribution to your template in the template user’s software.
To remove all claims to the templated snippets, distribute it under CC0, which is an international equivalent to public domain.
</p><pre><code class="">Template license
----------------
Written in &lt;YEAR&gt; by &lt;AUTHOR NAME&gt; &lt;AUTHOR E-MAIL ADDRESS&gt;
[other author/contributor lines as appropriate]

To the extent possible under law, the author(s) have dedicated all copyright and related
and neighboring rights to this template to the public domain worldwide.
This template is distributed without any warranty. See &lt;https://creativecommons.org/publicdomain/zero/1.0/&gt;.
</code></pre><h3 id="template+layout">template layout<a href="#template+layout" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The g8 runtime looks for templates in two locations in a given GitHub project:
</p><ul><li>If the <code>src/main/g8</code> directory is present it uses <code>src/main/g8</code> (<code>src</code> layout)
</li><li>If it does not exist, then the root directory is used (root layout)
</li></ul><h3 id="src+layout">src layout<a href="#src+layout" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This src layout is recommended so that it is easy for the template
itself to be an sbt project. That way,
an sbt plugin can be employed to locally test templates before pushing
changes to GitHub.
</p><p>The easy way to start a new template project is with a Giter8 template
made expressly for that purpose:
</p><pre><code>$ g8 foundweekends/giter8.g8
</code></pre><p>This will create an sbt project with stub template sources nested
under <code>src/main/g8</code>. The file <code>default.properties</code> defines template
fields and their default values using the Java properties file format.
</p><h3 id="default.properties">default.properties<a href="#default.properties" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><code>default.properties</code> file may be placed in <code>project/</code> directory,
or directly under the root of the template.
Properties are simple keys and values that replace them.
</p><p><a href="https://www.stringtemplate.org/">StringTemplate</a> is the engine
that applies Giter8 templates, so template fields in source files are
bracketed with the <code>$</code> character. For example, a “classname” field
might be referenced in the source as:
</p><pre><code>class $classname$ {
</code></pre><p>The template fields themselves can be utilized to define the defaults
of other fields.  For instance, you could build some URLs given the
user’s GitHub id:
</p><pre><code class="">name = URL Builder
github_id=githubber
developer_url=https://github.com/$github_id$
project_url=https://github.com/$github_id$/$name;format=&quot;norm&quot;$
</code></pre><p>This would yield the following in interactive mode:
</p><pre><code class="">name [URL Builder]: my-proj
github_id [githubber]: n8han
project_url [https://github.com/n8han/my-proj]:
developer_url [https://github.com/n8han]:
</code></pre><p>Dollar signs can be escaped to avoid resolution:
</p><pre><code class="">val foo = &quot;foo&quot;
val bar = &quot;bar&quot;
println(s&quot;\$foo\$bar&quot;)
</code></pre><p>This would yield to:
</p><pre><code class="">val foo = &quot;foo&quot;
val bar = &quot;bar&quot;
println(s&quot;$foo$bar&quot;)
</code></pre><p>Some variable names are prohibited since they’re tokens used by <a href="https://www.stringtemplate.org/">StringTemplate</a>
in its grammar, the complete list is <a href="https://github.com/antlr/stringtemplate4/blob/master/doc/cheatsheet.md">here</a> but the most common are:
</p><pre><code class="">&quot;i&quot;, &quot;i0&quot;, &quot;if&quot;, &quot;else&quot;, &quot;elseif&quot;, &quot;endif&quot;, &quot;first&quot;, &quot;length&quot;
&quot;strlen&quot;, &quot;last&quot;, &quot;rest&quot;, &quot;reverse&quot;, &quot;trunc&quot;, &quot;strip&quot;, &quot;trim&quot;
</code></pre><h3 id="Template+comments">Template comments<a href="#Template+comments" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Sometimes it’s useful to put a comment into a template that is intended for 
template maintainers, and should not be included in the generated output.
</p><p>Wrapping comments between <code>$!</code> and <code>!$</code> won’t make them appear in the output.
</p><pre><code class="">$! This comment won't appear in the output !$
// This comment will appear in the output
$!
This multiline comment won't appear either
No matter how
long it is

Internal $substitutions$ are ignored.

Even $invalid$ ones.

!$
/*
 * This comment is output and can contain $substitutions$
 */
</code></pre><h3 id="Conditionals">Conditionals<a href="#Conditionals" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>All fields have a property named <code>truthy</code> to be used in <a href="https://github.com/antlr/stringtemplate4/blob/master/doc/templates.md#conditionals">conditional expressions</a>.
<code>&quot;y&quot;</code>, <code>&quot;yes&quot;</code>, and <code>&quot;true&quot;</code> evaluate to <code>true</code>; anything else evaluates to <code>false</code>.
</p><pre><code class="">scala212 = yes
scala211 = no
</code></pre><p>These could be used in a template as follows:
</p><pre>
$if(scala212.truthy)$
scalaVersion := "2.12.3"
$elseif(scala211.truthy)$
scalaVersion := "2.11.11"
$else$
scalaVersion := "2.10.6"
$endif$
</pre><p>These could also be used include/exclude files or directories:
</p><pre><code class="prettyprint lang-bash">src/main/g8
├── $name__normalize$
│   ├── $if(jvm.truthy)$jvm$endif$
│   │   └── src
│   │       └── main
│   │           └── scala
│   │               └── $organization__packaged$
│   │                   └── $name;format=&quot;Camel&quot;$.scala

</code></pre><p>If you want to skip a directory from the path, but keep all nested directories and files, use <code>.</code> as the name of the directory. For example the next template:
</p><pre><code class="">src/main/g8
├── parent_folder
│   ├── $if(cond.truthy)$skip_folder$else$.$endif$
|   |   └── child_file
</code></pre><p>will be processed to
</p><pre><code class="">├── parent_folder
|   └── child_file
</code></pre><h3 id="name+field">name field<a href="#name+field" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>name</code> field, if defined, is treated specially by Giter8. It is
assumed to be the name of a project being created, so the g8 runtime
creates a directory based off that name (with spaces and capitals
replaced) that will contain the template output. If no name field is
specified in the template, <code>g8</code>’s output goes to the user’s current
working directory. In both cases, directories nested under the
template’s source directory are reproduced in its output. File and
directory names also participate in template expansion, e.g.
</p><pre><code>src/main/g8/src/main/scala/$classname$.scala
</code></pre><h3 id="package+field">package field<a href="#package+field" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>package</code> field, if defined, is assumed to be the package name
of the user’s source. A directory named <code>$package$</code> expands out to
package directory structure. For example, <code>net.databinder</code> becomes
<code>net/databinder</code>.
</p><h3 id="verbatim+field">verbatim field<a href="#verbatim+field" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>verbatim</code> field, if defined, is assumed to be the space delimited
list of file patterns such as <code>*.html *.js</code>. Files matching <code>verbatim</code>
pattern are excluded from string template processing.
</p><h3 id="Maven+properties">Maven properties<a href="#Maven+properties" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><em>maven properties</em> tell Giter8 to query the Central Maven Repository.
Instead of supplying a particular version (and having to update
the template with every release), specify a library and giter8 will
set the value to the latest version according to Maven Central.
</p><p>The property value format is <code>maven(groupId, artifactId)</code>.
Keep in mind that Scala projects are typically published with a
Scala version identifier in the artifact id. So for the Unfiltered
library, we could refer to the latest version as follows:
</p><pre><code class="">name = My Template Project
description = Creates a giter8 project template.
unfiltered_version = maven(ws.unfiltered, unfiltered_2.11)
</code></pre><p>To only use the latest stable release (excluding Milestone builds,
Release candidates etc) specify a “stable” value in the
property value format <code>maven(groupId, artifactId, stable)</code>.
To use the latest stable version for the Scalatest library
we could refer to it as follows:
</p><pre><code class="">name = My Template Project
description = Creates a giter8 project template.
scalatest_version = maven(org.scalatest, scalatest_2.11, stable)
</code></pre><h3 id="root+layout">root layout<a href="#root+layout" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There’s an experimental layout called root layout,
which uses the root directory of the GitHub project as
the root of template.
</p><p>Since you can no longer include template fields in the files
under <code>project</code> its application is very limited.
It might be useful for templates that are not for sbt builds
or templates without any fields.
</p><h3 id="Formatting+template+fields">Formatting template fields<a href="#Formatting+template+fields" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Giter8 has built-in support for formatting template fields. Formatting options
can be added when referencing fields. For example, the <code>name</code> field can be
formatted in upper camel case with:
</p><pre><code>$name;format=&quot;Camel&quot;$
</code></pre><p>The formatting options are:
</p><pre><code>upper      | uppercase       : all uppercase letters
lower      | lowercase       : all lowercase letters
cap        | capitalize      : uppercase first letter
decap      | decapitalize    : lowercase first letter
start      | start-case      : uppercase the first letter of each word
word       | word-only       : remove all non-word letters (only a-zA-Z0-9_)
space      | word-space      : replace all non-word letters (only a-zA-Z0-9) with a whitespace
Camel      | upper-camel     : upper camel case (start-case, word-only)
camel      | lower-camel     : lower camel case (start-case, word-only, decapitalize)
hyphen     | hyphenate       : replace spaces with hyphens
norm       | normalize       : all lowercase with hyphens (lowercase, hyphenate)
snake      | snake-case      : replace spaces and dots with underscores
dotReverse | dot-reverse     : tokenizes by dot and reverses the tokens (scala-lang.org -&gt; org.scala-lang)
package    | package-naming  : replace spaces with dots
packaged   | package-dir     : replace dots with slashes (net.databinder -&gt; net/databinder)
random     | generate-random : appends random characters to the given string
</code></pre><p>A <code>name</code> field with a value of <code>My Project</code> could be rendered in several ways:
</p><pre><code>$name$ -&gt; &quot;My Project&quot;
$name;format=&quot;camel&quot;$ -&gt; &quot;myProject&quot;
$name;format=&quot;Camel&quot;$ -&gt; &quot;MyProject&quot;
$name;format=&quot;normalize&quot;$ -&gt; &quot;my-project&quot;
$name;format=&quot;lower,hyphen&quot;$ -&gt; &quot;my-project&quot;
</code></pre><p>Note that multiple format options can be specified (comma-separated) which will
be applied in the order given.
</p><p>For file and directory names a format option can be specified after a double
underscore. For example, a directory named <code>$organization__packaged$</code> will
change <code>org.somewhere</code> to <code>org/somewhere</code> like the built-in support for
<code>package</code>. A file named <code>$name__Camel$.scala</code> and the name <code>awesome project</code>
will create the file <code>AwesomeProject.scala</code>. Multiple comma separated formatting 
options can be used at once: <code>$name__lower,hyphen$.scala</code> and the name 
<code>Awesome Project</code> will create the file <code>awesome-project.scala</code>.
</p><h3 id="Testing+templates+locally">Testing templates locally<a href="#Testing+templates+locally" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Templates may be passed to the <code>g8</code> command with a <code>file://</code> URL, and
in this case the template is applied as it is currently saved to the
file system. In conjunction with the <code>--force</code> option
which overwrites output files without prompting, you can test changes
to a template as you are making them.
</p><p>For example, if you have the Unfiltered template cloned locally you
could run a command like this:
</p><pre><code>$ g8 file://unfiltered.g8/ --name=uftest --force
</code></pre><p>In a separate terminal, test out the template.
</p><pre><code>$ cd uftest/
$ sbt
&gt; ~ compile
</code></pre><p>To make changes to the template, save them to its source under the
<code>.g8</code> directory, then repeat the command to apply the template in the
original terminal:
</p><pre><code>$ g8 file://unfiltered.g8/ --name=uftest --force
</code></pre><p>Your <code>uftest</code> sbt session, waiting with the <code>~ compile</code> command, will
detect the changes and automatically recompile.
</p><h3 id="Using+the+Giter8Plugin">Using the Giter8Plugin<a href="#Using+the+Giter8Plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Giter8 supplies an sbt plugin for testing templates before pushing
them to a GitHub branch. If you used the <code>foundweekends/giter8.g8</code> template
recommended above, it should already be configured.
</p><p>If you need to upgrade an existing template project to the current plugin, you can
add it as a source dependency in <code>project/giter8.sbt</code>:
</p><pre><code class="prettyprint lang-scala">addSbtPlugin(&quot;org.foundweekends.giter8&quot; % &quot;sbt-giter8&quot; % &quot;0.16.2&quot;)
</code></pre><p>When you enter sbt’s shell in the base directory of a
template project that is configured to use this plugin, the action
<code>g8Test</code> will apply the template in the default output directory
(under <code>target/sbt-test</code>) and run the <a href="https://www.scala-sbt.org/1.x/docs/Testing-sbt-plugins.html">scripted test</a>
for <em>that</em> project in a forked process.  You can supply the test scripted as
<code>project/giter8.test</code> or <code>src/test/g8/test</code>, otherwise <code>&gt;test</code> is used.
This is a good sanity check for templates that are supposed to produce sbt projects.
</p><p>But what if your template is not for an sbt project?
</p><pre><code>project/default.properties
TodaysMenu.html
</code></pre><p>You can still use sbt’s shell to test the template. The
lower level <code>g8</code> action will apply default field values
to the template and write it to the same <code>target/g8</code> directory.
</p><p>As soon as you push your template to GitHub (remember to name the
project with a <code>.g8</code> extension) you can test it with the actual g8
runtime. When you’re ready, add your template project to the
<a href="https://github.com/foundweekends/giter8/wiki/giter8-templates">the wiki</a> so other giter8 users can find it.
</p><h3 id="Using+Mill">Using Mill<a href="#Using+Mill" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There is also an external <a href="https://github.com/ckipp01/mill-giter8">Mill plugin</a> that can be used to test
your templates as well. An example setup can be found below:
</p><pre><code class="prettyprint lang-scala">import $ivy.`io.chris-kipp::mill-giter8::0.2.0`

import io.kipp.mill.giter8.G8Module

object g8 extends G8Module {
  override def validationTargets =
    Seq(&quot;example.compile&quot;, &quot;example.fix&quot;, &quot;example.reformat&quot;)
}
</code></pre><p>This plugin only supprts <a href="https://www.foundweekends.org/giter8/template.html#template+layout">`src` layouts</a>, but gives you some useful
targets like <code>g8.validate</code> which will both test the generation of your template
and also ensure any targets defined with <code>validationTargets</code> can also be ran
against your generated project.
</p><h2 id="Scaffolding+plugin">Scaffolding plugin<a href="#Scaffolding+plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Giter8 supplies an sbt plugin for creating and using scaffolds.
</p><h3 id="Using+the+scaffold+plugin">Using the scaffold plugin<a href="#Using+the+scaffold+plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Add the following lines in <code>project/scaffold.sbt</code>
</p><pre><code class="prettyprint lang-scala">addSbtPlugin(&quot;org.foundweekends.giter8&quot; % &quot;sbt-giter8-scaffold&quot; % &quot;0.16.2&quot;)
</code></pre><p>Once done, the  <code>g8Scaffold</code> command can be used in the sbt shell.
Use TAB completion to discover available templates.
</p><pre><code class="">&gt; g8Scaffold &lt;TAB&gt;
controller   global       model
</code></pre><p>To overwrite existing files pass the <code>--force</code> flag after the template:
</p><pre><code class="">&gt; g8Scaffold model --force
</code></pre><p>The template plugin will prompt each property that needed to complete the scaffolding process:
</p><pre><code class="">&gt; g8Scaffold controller
className [Application]:
</code></pre><h3 id="Creating+a+scaffold">Creating a scaffold<a href="#Creating+a+scaffold" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The g8 runtime looks for scaffolds in the <code>src/main/scaffolds</code> in the given GitHub project.
Each directory inside <code>src/main/scaffolds</code> is a different scaffold, and will be
accessible in the sbt shell using the directory name. Scaffold directories
may have a <code>default.properties</code> file to define field values, just like
ordinary templates. <code>name</code> is again a special field name: if it exists,
the scaffold will be generated into a directory based on <code>name</code>,
with subdirectories following the layout of the source scaffold directory.
</p><p>Once a template as been used, scaffolds are stored into <code>&lt;project_root&gt;/.g8</code>
</p><pre><code class="">$ ls sample/.g8
total 0
drwxr-xr-x   5 jtournay  staff   170B Aug  6 03:21 .
drwxr-xr-x  11 jtournay  staff   374B Aug  6 05:29 ..
drwxr-xr-x   4 jtournay  staff   136B Aug  6 03:21 controller
drwxr-xr-x   4 jtournay  staff   136B Aug  6 03:21 global
drwxr-xr-x   4 jtournay  staff   136B Aug  6 03:21 model
</code></pre><p>It’s also possible to create your own scaffold in any sbt project by creating the <code>.g8</code> directory.
</p><h2 id="Contributing">Contributing<a href="#Contributing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Installing+local+version+of+giter8">Installing local version of giter8<a href="#Installing+local+version+of+giter8" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When you’re working on giter8 locally you probably want 
to try out your changes before you open a pull request. This is how you do it.
</p><p>Giter8 uses [conscript] as distribution mechanism. You can find more documentation
about conscript on its [official page].
</p><h4 id="Fixing+%3A">Fixing <code>PATH</code>:<a href="#Fixing+%3A" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Before you install giter8 with conscript, you need to ensure, that
conscript directory has higher precedence than default installation path.
</p><p>You can either delete existing version of giter8, or change <code>PATH</code> variable such that 
<code>~/.conscript/bin</code> is before.
</p><h4 id="To+install+local+version%3A">To install local version:<a href="#To+install+local+version%3A" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Change <code>g8version</code> in <code>build.sbt</code> i.e. by adding <code>&quot;-SNAPSHOT&quot;</code>;
</li><li>Run <code>publishLocal</code> from sbt;
</li><li>From a shell session run <code>cs --local foundweekends/giter8/&lt;YOUR_VERSION&gt;</code>. 
Use the version number you just wrote in <code>build.sbt</code>.
</li></ul><h4 id="To+refresh%3A">To refresh:<a href="#To+refresh%3A" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Run <code>publishLocal</code> from sbt again;
</li><li>From a shell session run <code>cs --clean-boot</code>.
</li></ul><h4 id="To+get+back+to+normal+version%3A">To get back to normal version:<a href="#To+get+back+to+normal+version%3A" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>From a shell session run <code>cs foundweekends/giter8</code>.
</p>
                  </div>
                </div>
          </div> <!-- row -->
        </div>
        <div class="header">
          <div class="container-fluid top nav">
        <div class="row justify-content-md-center w-100">
          <div class="col-md-auto">
            <div class="title">
              <span>Giter8</span> — Combined Pages
            </div>
          </div>
        </div>
      </div>
        </div>
        <div class="footer">
          
        </div>
        
        
      </body>
    </html>